{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1476697252,"rating":192,"authorHandle":"zscoder","modificationTimeSeconds":1476698494,"id":47821,"title":"\u003cp\u003e[Tutorial] Slope Trick\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi everyone! Following my \u003ca href\u003d\"http://codeforces.com/blog/entry/47764\"\u003elast article\u003c/a\u003e, today I\u0027m writing about a not-so-common trick that has nevertheless appeared in some problems before and might be helpful to you. I\u0027m not sure if this trick has been given a name yet so I\u0027d refer to it as \u0026quot;Slope Trick\u0026quot; here.\u003c/p\u003e\u003cp\u003eDisclaimer : It would be helpful to have a pen and paper with you to sketch the graphs so that you can visualize these claims easier.\u003c/p\u003e\u003cp\u003eExample Problem 1 : \u003ca href\u003d\"/contest/713/problem/C\" title\u003d\"Codeforces Round 371 (Div. 1)\"\u003e713C - Sonya and Problem Wihtout a Legend\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis solution originated from \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/koosaga\" title\u003d\"Grandmaster koosaga\"\u003ekoosaga\u003c/a\u003e\u0027s comment in the editorial post \u003ca href\u003d\"http://codeforces.com/blog/entry/47094?#comment-315161\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThe solution below will solve this problem in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/5d/1f/5d1f29f648247e77966a5b1703590aea2a6a75b6.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e, wheareas the intended solution is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSo, the first step is to get rid of the strictly increasing condition. To do so, we apply \u003ccode\u003ea[i] -\u003d i\u003c/code\u003e for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e and thus we just have to find the minimum number of moves to change it to a non-decreasing sequence.\u003c/p\u003e\u003cp\u003eDefine \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e as the minimum number of moves to change the first \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e elements into a non-decreasing sequence such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIt is easy to see that by definition we have the recurrences\u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003eX\u003c/i\u003e) \u003d \u003ci\u003emin\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eY\u003c/i\u003e ≤ \u003ci\u003eX\u003c/i\u003e\u003c/sub\u003e(|\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003eY\u003c/i\u003e|)\u003c/span\u003e when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e \u003d 1\u003c/span\u003e \u003c/p\u003e\u003cp\u003eand \u003c/p\u003e\u003cp\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003eX\u003c/i\u003e) \u003d \u003ci\u003emin\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eY\u003c/i\u003e ≤ \u003ci\u003eX\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e(\u003ci\u003eY\u003c/i\u003e) + |\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003eY\u003c/i\u003e|}\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNow, note that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003eX\u003c/i\u003e)\u003c/span\u003e is non-increasing, since it is at most the minimum among all the values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003c/span\u003e for smaller \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e by definition. We store a set of integers that denotes where the function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e change slopes. More formally, we consider the function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003eX\u003c/i\u003e) \u003d \u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003eX\u003c/i\u003e + 1) - \u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003eX\u003c/i\u003e)\u003c/span\u003e. The last element of the set will be the smallest \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003ej\u003c/i\u003e) \u003d 0\u003c/span\u003e, the second last element will be the smallest \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e such that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003ej\u003c/i\u003e) \u003d  - 1\u003c/span\u003e, and so on. (note that the set of slope changing points is bounded)\u003c/p\u003e\u003cp\u003eLet \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eOpt\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e)\u003c/span\u003e denote a position where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003eX\u003c/i\u003e)\u003c/span\u003e achieves its minimum. (i.e. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003eOpt\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e)) \u003d 0\u003c/span\u003e) The desired answer will be \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003en\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003eOpt\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e))\u003c/span\u003e. We\u0027ll see how to update these values quickly.\u003c/p\u003e\u003cp\u003eNow, suppose we already have everything for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e\u003c/span\u003e. Now, we want to update the data for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. First, note that all the values \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u0026lt; \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e will have its slope decreased by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Also, every value with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e ≥ \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e will have its slope increased by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e unless we have reached the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eslope\u003c/i\u003e \u003d 0\u003c/span\u003e point, in which the graph never goes up again.\u003c/p\u003e\u003cp\u003eThere are two cases to consider :\u003c/p\u003e\u003cp\u003eCase 1 : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eOpt\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e - 1) ≤ \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003eHere, the slope at every point before \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e decreases by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Thus, we push \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e into the slope array as this indicates that we decreases the slope at all the slope changing points by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, and the slope changing point for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eslope\u003c/i\u003e \u003d 0\u003c/span\u003e is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, i.e. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eOpt\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e) \u003d \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Thus, this case is settled.\u003c/p\u003e\u003cp\u003eCase 2 : \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eOpt\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e - 1) \u0026gt; \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003eNow, we insert \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e into the set, since it decreases the slope at all the slope changing points before \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Furthermore, we insert \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e again because it increases the slope at the slope changing points between \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eOpt\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e - 1)\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Now, we can just take \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eOpt\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e) \u003d \u003ci\u003eOpt\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e - 1)\u003c/span\u003e since the slope at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eOpt\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e - 1)\u003c/span\u003e is still \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. Finally, we remove \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eOpt\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e - 1)\u003c/span\u003e from the set because it\u0027s no longer the first point where the slope changes to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. (it\u0027s the previous point where the slope changes to \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e and the slope now becomes \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e because of the addition of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e) Thus, the set of slope changing points is maintained. We have \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e(\u003ci\u003eOpt\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e)) \u003d \u003ci\u003ef\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e - 1\u003c/sub\u003e(\u003ci\u003eOpt\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e - 1)) + |\u003ci\u003eOpt\u003c/i\u003e(\u003ci\u003ei\u003c/i\u003e - 1) - \u003ci\u003ea\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e|\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThus, we can just use a priority queue to store the slope changing points and it is easy to see that the priority queue can handle all these operations efficiently (in \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/7c/4d/7c4d711d6db4afdaebd7dc33a74586d66f567bfc.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e time). \u003c/p\u003e\u003cp\u003eHere\u0027s the implementation of this idea by \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/koosaga\" title\u003d\"Grandmaster koosaga\"\u003ekoosaga\u003c/a\u003e : \u003ca href\u003d\"/contest/713/submission/20623607\" title\u003d\"Submission 20623607 by koosaga\"\u003e20623607\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis trick is called the \u0026quot;Slope Trick\u0026quot; because we\u0027re considering the general function and analyzing how its slope changes at different points to find the minimum or maximum value.\u003c/p\u003e\u003cp\u003eThe next example is \u003ca href\u003d\"https://github.com/apio-2016/apio2016-tasks/blob/master/fireworks/descriptions/en.pdf\"\u003eAPIO 2016 P2 — Fireworks\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis problem was the \u0026quot;killer\u0026quot; problem of APIO 2016, and was solved by merely \u003cspan class\u003d\"tex-span\"\u003e4\u003c/span\u003e contestants in the actual contest. \u003c/p\u003e\u003cp\u003eI\u0027ll explain the \u003cimg align\u003d\"middle\" class\u003d\"tex-formula\" src\u003d\"/predownloaded/36/89/3689fb456d98f097cd26490dc85bbb98bbe2902e.png\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e solution, which is relatively simple and demonstrates the idea of slope trick.\u003c/p\u003e\u003cp\u003eSo, the idea is similar to the last problem. For each node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, we store a function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e(\u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e which denotes the minimum cost to change the weights on edges in the entire subtree rooted at \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e including the parent edge of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e such that the sum of weights on each path from \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to leaves are equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e. We\u0027ll store the slope changing points of the function in a container (which we\u0027ll determine later) again. In addition, we store two integers \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e, which denotes that for all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e ≥ \u003ci\u003eX\u003c/i\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e is the largest slope changing point, the value of the function is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eaX\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. (clearly this function exists, since when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eX\u003c/i\u003e\u003c/span\u003e increases one can always increase the parent node by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e)\u003c/p\u003e\u003cp\u003eNow, for the child nodes \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, it is clear that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d 1, \u003ci\u003eb\u003c/i\u003e \u003d  - \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is the cost of the parent edge of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e, and the slope changing points are \u003cspan class\u003d\"tex-span\"\u003e{\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e}\u003c/span\u003e. \u003c/p\u003e\u003cp\u003eFor a non-leaf node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, we have to combine the functions from its children first. Firstly, we set the function as the sum of all functions of its child, and we\u0027ll correct it later. We set the value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e of this node as the sum of all \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003es of its children, and similarly for \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. Also, we combine all the slope-changing points together. It is important that we merge the smaller sets into the larger set. (see \u003ca href\u003d\"http://codeforces.com/blog/entry/44351\"\u003edsu on tree, a.k.a. small-to-large technique\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eNow, the function is still incorrect. Firstly, note that all the slope-changing points that have slope \u003cspan class\u003d\"tex-span\"\u003e \u0026gt; 1\u003c/span\u003e is meaningless, because we can just increase the parent edge by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e to increase the sum of the whole subtree, so we can remove these slope-changing points while updating the values of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e, \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. Suppose we remove a slope-changing point \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e with slope \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, then we decrement \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e, increase \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, and remove \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e from the set. (this is because \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eax\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e \u003d (\u003ci\u003ea\u003c/i\u003e - 1)\u003ci\u003ex\u003c/i\u003e + (\u003ci\u003eb\u003c/i\u003e + \u003ci\u003ex\u003c/i\u003e)\u003c/span\u003e) Repeat this till \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e becomes at most \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eNext, since the cost of the parent edge is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, we have to shift the slope \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e changing points to the right by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Note that the slope \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e changing point doesn\u0027t change, because we can just reduce the weight of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e until it reaches \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e. (note that the condition that the weights can be reduced to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e helped here)\u003c/p\u003e\u003cp\u003eFinally, we have to decrease \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, since we shifted the points to the right by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Thus, the function for this node is now complete.\u003c/p\u003e\u003cp\u003eThus, we can do a dfs and keep merging functions until we get the function for the root node. Then, we just have to find the value of the function when \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d 0\u003c/span\u003e. (using the same method by we decrease \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e until it reaches \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e) Finally, the answer will be the updated value of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e at the root node, and we\u0027re done.\u003c/p\u003e\u003cp\u003eWe\u0027ll use a priority queue to store the slope changing points as it is the most convenient option.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://github.com/apio-2016/apio2016-tasks/blob/master/fireworks/solutions/fireworks_seokhwan_nlg2n.cpp\"\u003eOfficial Solution\u003c/a\u003e\u003c/p\u003e\u003ch2\u003eBeyond APIO 2016 Fireworks\u003c/h2\u003e\u003cp\u003eNow, the next example is the generalization of this problem. It has came from \u003ca href\u003d\"https://www.codechef.com/OCT16/problems/TREEBAL\"\u003eCodechef October Challenge — Tree Balancing\u003c/a\u003e. We\u0027ll solve this using the slope trick as well.\u003c/p\u003e\u003cp\u003eThe Codechef problem is the same as the last problem, except :\u003c/p\u003e \u003col\u003e   \u003cli\u003e\u003cp\u003eThe weights of the edges can be changed to negative values\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eYou must output a possible construction aside from the minimum cost needed\u003c/p\u003e\u003c/li\u003e   \u003cli\u003e\u003cp\u003eThe edges now have a cost \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, and when you change the value of an edge by \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, your total cost increases by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e.\u003c/p\u003e\u003c/li\u003e \u003c/ol\u003e\u003cp\u003eHowever, it is still possible to solve this using Slope Trick. \u003c/p\u003e\u003cp\u003eFirstly, we suppose that \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ew\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e \u003d 1\u003c/span\u003e, to simplify the problem. Now, since the edges can be changed to negative values, at each node there is no point with slope that has absolute value greater than \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e, since changing the parent edge will yield a better result. Thus, each node actually have only \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e slope-changing points, the point where the slope changes from \u003cspan class\u003d\"tex-span\"\u003e - 1\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e and the point where the slope changes from \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. Thus, this means that we have to pop slope-changing points from the front as well as the back of the set. The best way to store the data is to use a multiset.\u003c/p\u003e\u003cp\u003eWith this modification, we can find the minimum cost needed like before. Now, the second part of the question is, how to reconstruct the answer? This part is not hard if you understand what we\u0027re doing here. The problem reduces to solving for each node \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e, if I need to make the sum of weights from the parent of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e to all leaves equal to \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e, what should the parent edge weight be, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e is given. We start from the childrens of the root, with value \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e\u003c/span\u003e which is equal to the point where the slope changes from \u003cspan class\u003d\"tex-span\"\u003e0\u003c/span\u003e to \u003cspan class\u003d\"tex-span\"\u003e1\u003c/span\u003e. (i.e. the point that yields minimum value)\u003c/p\u003e\u003cp\u003eFor each node we store the \u003cspan class\u003d\"tex-span\"\u003e2\u003c/span\u003e slope-changing points \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e in an array while we find the minimum cost. Now, if \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e ≤ \u003ci\u003ex\u003c/i\u003e ≤ \u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, then the best thing to do is not change the parent edge. If \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e \u0026gt; \u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, then we should increase the parent edge value by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ex\u003c/i\u003e - \u003ci\u003er\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Otherwise, we should decrease the parent edge value by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e - \u003ci\u003ex\u003c/i\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThus, we can find the required weights for the parent nodes and it remains to push the remaining sum of weights needed to its children and recurse until we get all the weights of the edges. The time complexity is the same.\u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://www.codechef.com/viewsolution/11786858\"\u003eMy submission for this case, which gives 20 points\u003c/a\u003e \u003c/p\u003e\u003cp\u003eTo get the full AC, we need to solve the cost-weighted case. It is actually similar to this case, but we have to modify the solution a bit.\u003c/p\u003e\u003cp\u003eThe idea is still the same. However, the slope changing points has increased by a lot. To efficiently store these slope points, we will store the compressed form of the set. For example, the set \u003cspan class\u003d\"tex-span\"\u003e{3, 4, 5, 5, 5, 5, 6, 6}\u003c/span\u003e will be stored as \u003cspan class\u003d\"tex-span\"\u003e{(3, 1), (4, 1), (5, 4), (6, 2)}\u003c/span\u003e. Basically, we store the number of occurences of the integers instead of storing it one by one. We can use a map to handle this.\u003c/p\u003e\u003cp\u003eThe base case is a bit different now. Suppose the leaf node is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/span\u003e and the cost of its parent edge is \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. Then, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e \u003d \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e, \u003ci\u003eb\u003c/i\u003e \u003d  - \u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e × \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, where \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e is the weight of its parent edge. The slope changing points is \u003cspan class\u003d\"tex-span\"\u003e{(\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e, 2\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e)}\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eMerging the functions to its parent will be the same. Now, we have to update the slope changing points and the function \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eax\u003c/i\u003e + \u003ci\u003eb\u003c/i\u003e\u003c/span\u003e. First, we remove all points with slope \u003cspan class\u003d\"tex-span\"\u003e \u0026gt; \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e \u0026lt;  - \u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e, as we can just change the parent edge. Then, we have to shift every slope changing point by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e. However, shifting the whole map naively is inefficient. The trick here is to store a counter \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eshift\u003c/i\u003e\u003c/span\u003e for each node that denotes the amount to add for each slope changing point. Now, the shifting part is equivalent to just adding \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ec\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003eu\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e to the counter \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eshift\u003c/i\u003e\u003c/span\u003e. Finally, we update \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ea\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eb\u003c/i\u003e\u003c/span\u003e as before.\u003c/p\u003e\u003cp\u003eTo recover the solution, we use the same method as above, with some changes. Firstly, \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003el\u003c/i\u003e\u003c/span\u003e and \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003er\u003c/i\u003e\u003c/span\u003e will be the minimum slope changing point of the function and maximum slope changing point of the function respectively. Secondly, if the sum of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e of all children is less than the \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ed\u003c/i\u003e\u003csub class\u003d\"lower-index\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/sub\u003e\u003c/span\u003e of the parent edge, then we do not change the weight of the parent edge, as it is sufficient to just update all the children edges. \u003c/p\u003e\u003cp\u003e\u003ca href\u003d\"https://www.codechef.com/viewsolution/11865552\"\u003eMy implementation of this solution (100 points)\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThat\u0027s it for this post. If you know any other application of this trick, feel free to post them in the comments.\u003c/p\u003e\u003c/div\u003e","tags":["slope trick","tutorial"]}}