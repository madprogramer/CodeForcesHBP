{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1420624094,"rating":971,"authorHandle":"Swift","modificationTimeSeconds":1511012557,"id":15643,"title":"\u003cp\u003eC++ Tricks\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch4\u003e**EDIT: A shorter error function **\u003c/h4\u003e\u003cp\u003eWARNING: Many of these things belong to C++11 so use C++11 in order to test anything here :)\u003c/p\u003e\u003cp\u003eI just write a short version for this article, because it\u0027s now in the main page. I recommend you to click on \u0026quot;Read more »\u0026quot; and read more :) Here is a short trick for the short version:\u003c/p\u003e\u003cp\u003eI see lots of programmers write code like this one:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epair\u0026lt;int, int\u0026gt; p;\nvector\u0026lt;int\u0026gt; v;\n// ...\np \u003d make_pair(3, 4);\nv.push_back(4); v.push_back(5);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ewhile you can just do this:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epair\u0026lt;int, int\u0026gt; p;\nvector\u0026lt;int\u0026gt; v;\n// ...\np \u003d {3, 4};\nv \u003d {4, 5};\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e1. Assign value by a pair of {} to a container\u003c/h4\u003e\u003cp\u003eI see lots of programmers write code like this one:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epair\u0026lt;int, int\u0026gt; p;\n// ...\np \u003d make_pair(3, 4);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ewhile you can just do this:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epair\u0026lt;int, int\u0026gt; p;\n// ...\np \u003d {3, 4};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eeven a more complex \u003ccode\u003epair\u003c/code\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003epair\u0026lt;int, pair\u0026lt;char, long long\u0026gt; \u0026gt; p;\n// ...\np \u003d {3, {\u0027a\u0027, 8ll}};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhat about \u003ccode\u003evector\u003c/code\u003e, \u003ccode\u003edeque\u003c/code\u003e, \u003ccode\u003eset\u003c/code\u003e and other containers?\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e\u003cbr /\u003evector\u0026lt;int\u0026gt; v;\nv \u003d {1, 2, 5, 2};\nfor (auto i: v)\n    cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0027 \u0027;\ncout \u0026lt;\u0026lt; \u0027\\n\u0027;\n// prints \u0026quot;1 2 5 2\u0026quot;\n\n\ndeque\u0026lt;vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt; d;\nd \u003d {{{3, 4}, {5, 6}}, {{1, 2}, {3, 4}}};\nfor (auto i: d) {\n    for (auto j: i)\n        cout \u0026lt;\u0026lt; j.first \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; j.second \u0026lt;\u0026lt; \u0027\\n\u0027;\n    cout \u0026lt;\u0026lt; \u0026quot;-\\n\u0026quot;;\n}\n// prints \u0026quot;3 4\n//         5 6\n//         -\n//\t   1 2\n//\t   3 4\n//\t   -\u0026quot;\n\n\nset\u0026lt;int\u0026gt; s;\ns \u003d {4, 6, 2, 7, 4};\nfor (auto i: s)\n    cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0027 \u0027;\ncout \u0026lt;\u0026lt; \u0027\\n\u0027;\n// prints \u0026quot;2 4 6 7\u0026quot;\n\n\nlist\u0026lt;int\u0026gt; l;\nl \u003d {5, 6, 9, 1};\nfor (auto i: l)\n    cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0027 \u0027;\ncout \u0026lt;\u0026lt; \u0027\\n\u0027;\n// prints \u0026quot;5 6 9 1\u0026quot;\n\n\narray\u0026lt;int, 4\u0026gt; a;\na \u003d {5, 8, 9, 2};\nfor (auto i: a)\n    cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0027 \u0027;\ncout \u0026lt;\u0026lt; \u0027\\n\u0027;\n// prints \u0026quot;5 8 9 2\u0026quot;\n\n\ntuple\u0026lt;int, int, char\u0026gt; t;\nt \u003d {3, 4, \u0027f\u0027};\ncout \u0026lt;\u0026lt; get\u0026lt;2\u0026gt;(t) \u0026lt;\u0026lt; \u0027\\n\u0027;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNote that it doesn\u0027t work for \u003ccode\u003estack\u003c/code\u003e and \u003ccode\u003equeue\u003c/code\u003e.\u003c/p\u003e\u003ch4\u003e2. Name of argument in macros\u003c/h4\u003e\u003cp\u003eYou can use \u0027#\u0027 sign to get exact name of an argument passed to a macro:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#define what_is(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026quot; is \u0026quot; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl;\n// ...\nint a_variable \u003d 376;\nwhat_is(a_variable);\n// prints \u0026quot;a_variable is 376\u0026quot;\nwhat_is(a_variable * 2 + 1)\n// prints \u0026quot;a_variable * 2 + 1 is 753\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e3. Get rid of those includes!\u003c/h4\u003e\u003cp\u003eSimply use\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis library includes many of libraries we do need in contest like \u003ccode\u003ealgorithm\u003c/code\u003e, \u003ccode\u003eiostream\u003c/code\u003e, \u003ccode\u003evector\u003c/code\u003e and many more. Believe me you don\u0027t need to include anything else!\u003c/p\u003e\u003ch4\u003e4. Hidden function (not really hidden but not used often)\u003c/h4\u003e\u003cp\u003eone)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e__gcd(value1, value2)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou don\u0027t need to code Euclidean Algorithm for a gcd function, from now on we can use. This function returns gcd of two numbers.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003ee.g.\u003c/strong\u003e __gcd(18, 27) \u003d 9.\u003c/p\u003e\u003cp\u003etwo)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e__builtin_ffs(x)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis function returns 1 + least significant 1-bit of x. If x \u003d\u003d 0, returns 0. Here x is \u003ccode\u003eint\u003c/code\u003e, this function with suffix \u0027l\u0027 gets a \u003ccode\u003elong\u003c/code\u003e argument and with suffix \u0027ll\u0027 gets a \u003ccode\u003elong long\u003c/code\u003e argument.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003ee.g.\u003c/strong\u003e __builtin_ffs(10) \u003d 2 because 10 is \u0027...10 \u003cstrong\u003e1\u003c/strong\u003e 0\u0027 in base 2 and first 1-bit from right is at index 1 (0-based) and function returns 1 + index.\u003c/p\u003e\u003cp\u003ethree)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e__builtin_clz(x)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis function returns number of leading 0-bits of x which starts from most significant bit position. x is \u003ccode\u003eunsigned int\u003c/code\u003e and like previous function this function with suffix \u0027l  gets a \u003ccode\u003eunsigned long\u003c/code\u003e argument and with suffix \u0027ll\u0027 gets a \u003ccode\u003eunsigned long long\u003c/code\u003e argument. If x \u003d\u003d 0, returns an undefined value.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003ee.g.\u003c/strong\u003e __builtin_clz(16) \u003d 27 because 16 is \u0027 \u003cstrong\u003e...\u003c/strong\u003e 10000\u0027. Number of bits in a \u003ccode\u003eunsigned int\u003c/code\u003e is 32. so function returns 32 — 5 \u003d 27.\u003c/p\u003e\u003cp\u003efour)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e__builtin_ctz(x)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis function returns number of trailing 0-bits of x which starts from least significant bit position. x is \u003ccode\u003eunsigned int\u003c/code\u003e and like previous function this function with suffix \u0027l\u0027 gets a \u003ccode\u003eunsigned long\u003c/code\u003e argument and with suffix \u0027ll\u0027 gets a \u003ccode\u003eunsigned long long\u003c/code\u003e argument. If x \u003d\u003d 0, returns an undefined value.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003ee.g.\u003c/strong\u003e __builtin_ctz(16) \u003d 4 because 16 is \u0027...1 \u003cstrong\u003e0000\u003c/strong\u003e \u0027. Number of trailing 0-bits is 4.\u003c/p\u003e\u003cp\u003efive)\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e__builtin_popcount(x)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis function returns number of 1-bits of x. x is \u003ccode\u003eunsigned int\u003c/code\u003e and like previous function this function with suffix \u0027l\u0027 gets a \u003ccode\u003eunsigned long\u003c/code\u003e argument and with suffix \u0027ll\u0027 gets a \u003ccode\u003eunsigned long long\u003c/code\u003e argument. If x \u003d\u003d 0, returns an undefined value.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003ee.g.\u003c/strong\u003e __builtin_popcount(14) \u003d 3 because 14 is \u0027... \u003cstrong\u003e111\u003c/strong\u003e 0\u0027 and has three 1-bits.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e There are other \u003ccode\u003e__builtin\u003c/code\u003e functions too, but they are not as useful as these ones.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e Other functions are not unknown to bring them here but if you are interested to work with them, I suggest \u003ca href\u003d\"http://www.cplusplus.com\"\u003ethis website\u003c/a\u003e.\u003c/p\u003e\u003ch4\u003e5. Variadic Functions and Macros\u003c/h4\u003e\u003cp\u003eWe can have a variadic function. I want to write a sum function which gets a number of ints, and returns sum of them. Look at the code below:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint sum() { return 0; }\n\ntemplate\u0026lt;typename... Args\u0026gt;\nint sum(int a, Args... args) { return a + sum(args...); }\n\nint main() { cout \u0026lt;\u0026lt; sum(5, 7, 2, 2) + sum(3, 4); /* prints \u0026quot;23\u0026quot; */ }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn the code above I used a template. sum(5, 7, 2, 2) becomes 5 + sum(7, 2, 2) then sum(7, 2, 2), itself, becomes 7 + sum(2, 2) and so on... I also declare another sum function which gets 0 arguments and returns 0.\u003c/p\u003e\u003cp\u003eI can even define a any-type sum function:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eint sum() { return 0; }\n\ntemplate\u0026lt;typename T, typename... Args\u0026gt;\nT sum(T a, Args... args) { return a + sum(args...); }\n\nint main() { cout \u0026lt;\u0026lt; sum(5, 7, 2, 2) + sum(3.14, 4.89); /* prints \u0026quot;24.03\u0026quot; */ }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHere, I just changed \u003ccode\u003eint\u003c/code\u003e to \u003ccode\u003eT\u003c/code\u003e and added \u003ccode\u003etypename T\u003c/code\u003e to my template.\u003c/p\u003e\u003cp\u003eIn C++14 you can also use \u003ccode\u003eauto sum(T a, Args... args)\u003c/code\u003e in order to get sum of mixed types. (Thanks to \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/slycelote\" title\u003d\"Candidate Master slycelote\"\u003eslycelote\u003c/a\u003e and \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/Corei13\" title\u003d\"Candidate Master Corei13\"\u003eCorei13\u003c/a\u003e)\u003c/p\u003e\u003cp\u003eWe can also use variadic macros:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#define a_macro(args...) sum(args...)\n\nint sum() { return 0; }\n\ntemplate\u0026lt;typename T, typename... Args\u0026gt;\nauto sum(T a, Args... args) { return a + sum(args...); }\n\nint main() { cout \u0026lt;\u0026lt; a_macro(5, 7, 2, 2) + a_macro(3.14, 4.89); /* prints \u0026quot;24.03\u0026quot; */ }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eUsing these 2, we can have a great debugging function: (thanks to \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Igorjan94\" title\u003d\"Expert Igorjan94\"\u003eIgorjan94\u003c/a\u003e) — \u003cem\u003eUpdated!\u003c/em\u003e\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\n#define error(args...) { string _s \u003d #args; replace(_s.begin(), _s.end(), \u0027,\u0027, \u0027 \u0027); stringstream _ss(_s); istream_iterator\u0026lt;string\u0026gt; _it(_ss); err(_it, args); }\n\nvoid err(istream_iterator\u0026lt;string\u0026gt; it) {}\ntemplate\u0026lt;typename T, typename... Args\u0026gt;\nvoid err(istream_iterator\u0026lt;string\u0026gt; it, T a, Args... args) {\n\tcerr \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026quot; \u003d \u0026quot; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl;\n\terr(++it, args...);\n}\n\nint main() {\n\tint a \u003d 4, b \u003d 8, c \u003d 9;\n\terror(a, b, c);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOutput:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ea \u003d 4\nb \u003d 8\nc \u003d 9\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis function helps a lot in debugging.\u003c/p\u003e\u003ch4\u003e6. Here is C++0x in CF, why still C++?\u003c/h4\u003e\u003cp\u003eVariadic functions also belong to C++11 or C++0x, In this section I want to show you some great features of C++11.\u003c/p\u003e\u003cp\u003eone) Range-based For-loop\u003c/p\u003e\u003cp\u003eHere is a piece of an old code:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eset\u0026lt;int\u0026gt; s \u003d {8, 2, 3, 1};\nfor (set\u0026lt;int\u0026gt;::iterator it \u003d s.begin(); it !\u003d s.end(); ++it)\n    cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0027 \u0027;\n// prints \u0026quot;1 2 3 8\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTrust me, that\u0027s a lot of code for that, just use this:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eset\u0026lt;int\u0026gt; s \u003d {8, 2, 3, 1};\nfor (auto it: s)\n    cout \u0026lt;\u0026lt; it \u0026lt;\u0026lt; \u0027 \u0027;\n// prints \u0026quot;1 2 3 8\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe can also change the values just change \u003ccode\u003eauto\u003c/code\u003e with \u003ccode\u003eauto \u0026amp;\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evector\u0026lt;int\u0026gt; v \u003d {8, 2, 3, 1};\nfor (auto \u0026amp;it: v)\n    it *\u003d 2;\nfor (auto it: v)\n    cout \u0026lt;\u0026lt; it \u0026lt;\u0026lt; \u0027 \u0027;\n// prints \u0026quot;16 4 6 2\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003etwo) The Power of \u003ccode\u003eauto\u003c/code\u003e\u003c/p\u003e\u003cp\u003eYou don\u0027t need to name the type you want to use, C++11 can infer it for you. If you need to loop over iterators of a set\u0026lt;pair\u0026lt;int, pair\u0026lt;int, int\u0026gt; \u0026gt; \u0026gt; from begin to end, you need to type \u003ccode\u003eset\u0026lt;pair\u0026lt;int, pair\u0026lt;int, int\u0026gt; \u0026gt; \u0026gt;::iterator\u003c/code\u003e for me it\u0027s so suffering! just use auto it \u003d s.begin()\u003c/p\u003e\u003cp\u003ealso x.begin() and x.end() now are accessible using begin(x) and end(x).\u003c/p\u003e\u003cp\u003eThere are more things. I think I said useful features. Maybe I add somethings else to post. If you know anything useful please share with Codeforces community :)\u003c/p\u003e\u003cp\u003eFrom \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/Ximera\" title\u003d\"Candidate Master Ximera\"\u003eXimera\u003c/a\u003e\u0027s comment:\u003c/p\u003e\u003cp\u003ethis code:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor(i \u003d 1; i \u0026lt;\u003d n; i++) {\n    for(j \u003d 1; j \u0026lt;\u003d m; j++)\n        cout \u0026lt;\u0026lt; a[i][j] \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n    cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eis equivalent to this:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003efor(i \u003d 1; i \u0026lt;\u003d n; i++)\n    for(j \u003d 1; j \u0026lt;\u003d m; j++)\n        cout \u0026lt;\u0026lt; a[i][j] \u0026lt;\u0026lt; \u0026quot; \\n\u0026quot;[j \u003d\u003d m];\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd here is the reason: \u003ccode\u003e\u0026quot; \\n\u0026quot;\u003c/code\u003e is a \u003ccode\u003echar*\u003c/code\u003e, \u003ccode\u003e\u0026quot; \\n\u0026quot;[0]\u003c/code\u003e is \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0026quot; \\n\u0026quot;[1]\u003c/code\u003e is \u003ccode\u003e\u0027\\n\u0027\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eFrom \u003ca class\u003d\"rated-user user-cyan\" href\u003d\"/profile/technetium28\" title\u003d\"Specialist technetium28\"\u003etechnetium28\u003c/a\u003e\u0027s comment:\u003c/p\u003e\u003cp\u003eUsage of \u003ccode\u003etie\u003c/code\u003e and \u003ccode\u003eemplace_back\u003c/code\u003e:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#define mt make_tuple\n#define eb emplace_back\ntypedef tuple\u0026lt;int,int,int\u0026gt; State; // operator\u0026lt; defined\n\nint main(){\n  int a,b,c;\n  tie(a,b,c) \u003d mt(1,2,3); // assign\n  tie(a,b) \u003d mt(b,a); // swap(a,b)\n\n  vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; v;\n  v.eb(a,b); // shorter and faster than pb(mp(a,b))\n\n  // Dijkstra\n  priority_queue\u0026lt;State\u0026gt; q;\n  q.emplace(0,src,-1);\n  while(q.size()){\n    int dist, node, prev;\n    tie(dist, ode, prev) \u003d q.top(); q.pop();\n    dist \u003d -dist;\n    // ~~ find next state ~~\n    q.emplace(-new_dist, new_node, node);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd that\u0027s why \u003ccode\u003eemplace_back\u003c/code\u003e faster: \u003ccode\u003eemplace_back\u003c/code\u003e is faster than \u003ccode\u003epush_back\u003c/code\u003e \u0027cause it just construct value at the end of vector but \u003ccode\u003epush_back\u003c/code\u003e construct it somewhere else and then move it to the vector.\u003c/p\u003e\u003cp\u003eAlso in the code above you can see how \u003ccode\u003etie(args...)\u003c/code\u003e works. You can also use \u003ccode\u003eignore\u003c/code\u003e keyword in \u003ccode\u003etie\u003c/code\u003e to ignore a value:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003etuple\u0026lt;int, int, int, char\u0026gt; t (3, 4, 5, \u0027g\u0027);\nint a, b;\ntie(b, ignore, a, ignore) \u003d t;\ncout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0027\\n\u0027;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOutput: \u003ccode\u003e5 3\u003c/code\u003e\u003c/p\u003e\u003cp\u003eI use this macro and I love it:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e#define rep(i, begin, end) for (__typeof(end) i \u003d (begin) - ((begin) \u0026gt; (end)); i !\u003d (end) - ((begin) \u0026gt; (end)); i +\u003d 1 - 2 * ((begin) \u0026gt; (end)))\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFirst of all, you don\u0027t need to name the type you want to use. Second of all it goes forwards and backwards based on (begin \u0026gt; end) condition. e.g. \u003ccode\u003erep(i, 1, 10)\u003c/code\u003e is 1, 2, ..., 8, 9 and \u003ccode\u003erep(i, 10, 1)\u003c/code\u003e is 9, 8, ..., 2, 1\u003c/p\u003e\u003cp\u003eIt works well with different types e.g.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evector\u0026lt;int\u0026gt; v \u003d {4, 5, 6, 4, 8};\nrep(it, end(v), begin(v))\n    cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0027 \u0027;\n// prints \u0026quot;8 4 6 5 4\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAlso there is another great feature of C++11, lambda functions!\u003c/p\u003e\u003cp\u003eLambdas are like other languages\u0027 closure. It defines like this:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e[capture list](parameters) -\u0026gt; return value { body }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eone) Capture List: simple! We don\u0027t need it here, so just put \u003ccode\u003e[]\u003c/code\u003e\u003c/p\u003e\u003cp\u003etwo) parameters: simple! e.g. int x, string s\u003c/p\u003e\u003cp\u003ethree) return value: simple again! e.g. pair\u0026lt;int, int\u0026gt; which can be omitted most of the times (thanks to \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/Jacob\" title\u003d\"International master Jacob\"\u003eJacob\u003c/a\u003e)\u003c/p\u003e\u003cp\u003efour) body: contains function bodies, and returns return value.\u003c/p\u003e\u003cp\u003ee.g.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eauto f \u003d [] (int a, int b) -\u0026gt; int { return a + b; };\ncout \u0026lt;\u0026lt; f(1, 2); // prints \u0026quot;3\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou can use lambdas in \u003ccode\u003efor_each\u003c/code\u003e, \u003ccode\u003esort\u003c/code\u003e and many more STL functions:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003evector\u0026lt;int\u0026gt; v \u003d {3, 1, 2, 1, 8};\nsort(begin(v), end(v), [] (int a, int b) { return a \u0026gt; b; });\nfor (auto i: v) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0027 \u0027;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOutput:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e8 3 2 1 1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFrom \u003ca class\u003d\"rated-user user-blue\" href\u003d\"/profile/Igorjan94\" title\u003d\"Expert Igorjan94\"\u003eIgorjan94\u003c/a\u003e\u0027s comment:\u003c/p\u003e\u003cp\u003eUsage of \u003ccode\u003emove\u003c/code\u003e:\u003c/p\u003e\u003cp\u003eWhen you work with STL containers like \u003ccode\u003evector\u003c/code\u003e, you can use \u003ccode\u003emove\u003c/code\u003e function to just move container, not to copy it all. \u003c/p\u003e \u003cpre\u003e\u003ccode\u003evector\u0026lt;int\u0026gt; v \u003d {1, 2, 3, 4};\nvector\u0026lt;int\u0026gt; w \u003d move(v);\n\ncout \u0026lt;\u0026lt; \u0026quot;v: \u0026quot;;\nfor (auto i: v)\n    cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0027 \u0027;\n\ncout \u0026lt;\u0026lt; \u0026quot;\\nw: \u0026quot;;\nfor (auto i: w)\n    cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0027 \u0027;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOutput:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003ev: \nw: 1 2 3 4 \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAs you can see \u003ccode\u003ev\u003c/code\u003e moved to \u003ccode\u003ew\u003c/code\u003e and not copied.\u003c/p\u003e\u003ch4\u003e7. C++0x Strings\u003c/h4\u003e\u003cp\u003eone) Raw Strings (From \u003ca class\u003d\"rated-user user-violet\" href\u003d\"/profile/IvayloS\" title\u003d\"Candidate Master IvayloS\"\u003eIvayloS\u003c/a\u003e\u0027s comment)\u003c/p\u003e\u003cp\u003eYou can have UTF-8 strings, Raw strings and more. Here I want to show raw strings. We define a raw string as below:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003estring s \u003d R\u0026quot;(Hello, World!)\u0026quot;; // Stored: \u0026quot;Hello, World!\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eA raw string skips all escape characters like \u003ccode\u003e\\n\u003c/code\u003e or \u003ccode\u003e\\\u0026quot;\u003c/code\u003e. e.g.\u003c/p\u003e \u003cpre\u003e\u003ccode\u003estring str \u003d \u0026quot;Hello\\tWorld\\n\u0026quot;;\nstring r_str \u003d R\u0026quot;(Hello\\tWorld\\n)\u0026quot;;\ncout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; r_str;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOutput:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eHello\tWorld\nHello\\tWorld\\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou can also have multiple line raw string:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003estring r_str \u003d\nR\u0026quot;(Dear Programmers,\nI\u0027m using C++11\nRegards, Swift!)\u0026quot;;\ncout \u0026lt;\u0026lt; r_str;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOutput:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eDear Programmer,\nI\u0027m using C++11\nRegards, Swift!\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003etwo) Regular Expressions (regex)\u003c/p\u003e\u003cp\u003eRegular expressions are useful tools in programming, we can define a regular expression by \u003ccode\u003eregex\u003c/code\u003e e.g. \u003ccode\u003eregex r \u003d \u0026quot;[a-z]+\u0026quot;;\u003c/code\u003e. We will use raw string for them because sometimes they have \u003ccode\u003e\\\u003c/code\u003e and other characters. Look at the example:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eregex email_pattern(R\u0026quot;(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$)\u0026quot;); // This email pattern is not totally correct! It\u0027s correct for most emails.\n\nstring\nvalid_email(\u0026quot;swift@codeforces.com\u0026quot;),\ninvalid_email(\u0026quot;hello world\u0026quot;);\n\nif (regex_match(valid_email, email_pattern))\n    cout \u0026lt;\u0026lt; valid_email \u0026lt;\u0026lt; \u0026quot; is valid\\n\u0026quot;;\nelse\n    cout \u0026lt;\u0026lt; valid_email \u0026lt;\u0026lt; \u0026quot; is invalid\\n\u0026quot;;\n\nif (regex_match(invalid_email, email_pattern))\n    cout \u0026lt;\u0026lt; invalid_email \u0026lt;\u0026lt; \u0026quot; is valid\\n\u0026quot;;\nelse\n    cout \u0026lt;\u0026lt; invalid_email \u0026lt;\u0026lt; \u0026quot; is invalid\\n\u0026quot;;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOutput:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003eswift@codeforces.com is valid\nhello world is invalid\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e You can learn Regex in \u003ca href\u003d\"http://regexone.com\"\u003ethis website\u003c/a\u003e.\u003c/p\u003e\u003cp\u003ethree) User-defined literals\u003c/p\u003e\u003cp\u003eYou already know literals from C++ like: \u003ccode\u003e0xA\u003c/code\u003e, \u003ccode\u003e1000ll\u003c/code\u003e, \u003ccode\u003e3.14f\u003c/code\u003e and so on...\u003c/p\u003e\u003cp\u003eNow you can have your own custom literals! Sounds great :) So let\u0027s see an example:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003elong long operator \u0026quot;\u0026quot; _m(unsigned long long literal) {\n\treturn literal;\n}\n\nlong double operator \u0026quot;\u0026quot; _cm(unsigned long long literal) {\n\treturn literal / 100.0;\n}\n\nlong long operator \u0026quot;\u0026quot; _km(unsigned long long literal) {\n\treturn literal * 1000;\n}\n\nint main() {\n\t// See results in meter:\n\tcout \u0026lt;\u0026lt; 250_m \u0026lt;\u0026lt; \u0026quot; meters \\n\u0026quot;; // Prints 250 meters\n\tcout \u0026lt;\u0026lt; 12_km \u0026lt;\u0026lt; \u0026quot; meters \\n\u0026quot;; // Prints 12000 meters\n\tcout \u0026lt;\u0026lt; 421_cm \u0026lt;\u0026lt; \u0026quot; meters \\n\u0026quot;; // Prints 4.21 meters\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNote that a literal should start with an underscore (\u003ccode\u003e_\u003c/code\u003e). We declare a new literal by this pattern:\u003c/p\u003e \u003cpre\u003e\u003ccode\u003e[returnType] operator \u0026quot;\u0026quot; _[name]([parameters]) { [body] }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003enote that parameters only can be one of these:\u003c/p\u003e\u003cp\u003e\u003ccode\u003e(const char *)\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003e(unsigned long long int)\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003e(long double)\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003e(char)\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003e(wchar_t)\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003e(char16_t)\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003e(char32_t)\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003e(const char *, size_t)\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003e(const wchar_t *, size_t)\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003e(const char16_t *, size_t)\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003e(const char32_t *, size_t)\u003c/code\u003e\u003c/p\u003e\u003cp\u003eLiterals also can used with templates.\u003c/p\u003e\u003cp\u003eTo be continued :)\u003c/p\u003e\u003c/div\u003e","tags":["c++","c++0x","tricks"]}}